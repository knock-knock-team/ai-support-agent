from __future__ import annotations
import uuid
from typing import List, Optional

from fastapi import HTTPException
from anyio import to_thread

from .config import settings

from rag_system.models.schemas import Document, RetrievalResult
from rag_system.embeddings.sentence_transformer_embedder import SentenceTransformerEmbedder
from rag_system.vectorstore.qdrant_store import QdrantVectorStore
from rag_system.indexing.indexer import Indexer
from rag_system.retrieval.retriever import Retriever


class RagService:
    def __init__(self) -> None:
        embedder = SentenceTransformerEmbedder(model_name=settings.embedding_model)
        vector_store = QdrantVectorStore()
        self._indexer = Indexer(embedder=embedder, vector_store=vector_store)
        self._retriever = Retriever(embedder=embedder, vector_store=vector_store)

    async def add_documents(self, documents: List[str]) -> None:
        # convert to Document objects with autogenerated ids
        docs = [Document(id=str(uuid.uuid4()), text=text) for text in documents]
        try:
            await to_thread.run_sync(self._indexer.index_documents, docs)
        except Exception as exc:
            raise HTTPException(status_code=500, detail=str(exc))

    async def search(self, query: str, top_k: Optional[int] = None) -> List[RetrievalResult]:
        tk = top_k or settings.default_top_k
        try:
            results = await to_thread.run_sync(self._retriever.retrieve, query, tk)
            return results
        except Exception as exc:
            raise HTTPException(status_code=500, detail=str(exc))

    async def health(self) -> dict:
        # simple check: attempt to ping vector store or embedder
        info: dict = {
            "embeddings_model": settings.embedding_model,
            "qdrant_url": settings.qdrant_url,
        }
        return info
